## 과제 체크포인트

### 배포 링크
https://dev-learning1.github.io/hanghae-plus_front_7th_chapter2-1/

<!--
배포 링크를 적어주세요
예시: https://<username>.github.io/front-7th-chapter2-1/

배포가 완료되지 않으면 과제를 통과할 수 없습니다.
배포 후에 정상 작동하는지 확인해주세요.
-->

### 기본과제

#### 상품목록

**상품 목록 로딩**

- [✅] 페이지 접속 시 로딩 상태가 표시된다
- [✅] 데이터 로드 완료 후 상품 목록이 렌더링된다
- [❌] 로딩 실패 시 에러 상태가 표시된다
- [❌] 에러 발생 시 재시도 버튼이 제공된다

**상품 목록 조회**

- [✅] 각 상품의 기본 정보(이미지, 상품명, 가격)가 카드 형태로 표시된다

**한 페이지에 보여질 상품 수 선택**

- [✅] 드롭다운에서 10, 20, 50, 100개 중 선택할 수 있으며 기본 값은 20개 이다.
- [✅] 선택 변경 시 즉시 목록에 반영된다

**상품 정렬 기능**

- [✅] 상품을 가격순/이름순으로 오름차순/내림차순 정렬을 할 수 있다.
- [✅] 드롭다운을 통해 정렬 기준을 선택할 수 있다
- [✅] 정렬 변경 시 즉시 목록에 반영된다

**무한 스크롤 페이지네이션**

- [✅] 페이지 하단 근처 도달 시 다음 페이지 데이터가 자동 로드된다
- [✅] 스크롤에 따라 계속해서 새로운 상품들이 목록에 추가된다
- [✅] 새 데이터 로드 중일 때 로딩 인디케이터와 스켈레톤 UI가 표시된다
- [✅] 홈 페이지에서만 무한 스크롤이 활성화된다

**상품을 장바구니에 담기**

- [✅] 각 상품에 장바구니 추가 버튼이 있다
- [❌] 버튼 클릭 시 해당 상품이 장바구니에 추가된다
- [❌] 추가 완료 시 사용자에게 알림이 표시된다

**상품 검색**

- [✅] 상품명 기반 검색을 위한 텍스트 입력 필드가 있다
- [✅] Enter 키로 검색이 수행된다
- [✅] 검색어와 일치하는 상품들만 목록에 표시된다

**카테고리 선택**

- [✅] 사용 가능한 카테고리들을 선택할 수 있는 UI가 제공된다
- [✅] 선택된 카테고리에 해당하는 상품들만 표시된다
- [✅] 전체 상품 보기로 돌아갈 수 있다
- [✅] 2단계 카테고리 구조를 지원한다 (1depth, 2depth)

**카테고리 네비게이션**

- [✅] 현재 선택된 카테고리 경로가 브레드크럼으로 표시된다
- [✅] 브레드크럼의 각 단계를 클릭하여 상위 카테고리로 이동할 수 있다
- [✅] "전체" > "1depth 카테고리" > "2depth 카테고리" 형태로 표시된다

**현재 상품 수 표시**

- [❌] 현재 조건에서 조회된 총 상품 수가 화면에 표시된다
- [✅] 검색이나 필터 적용 시 상품 수가 실시간으로 업데이트된다

#### 장바구니

**장바구니 모달**

- [❌] 장바구니 아이콘 클릭 시 모달 형태로 장바구니가 열린다
- [❌] X 버튼이나 배경 클릭으로 모달을 닫을 수 있다
- [❌] ESC 키로 모달을 닫을 수 있다
- [❌] 모달에서 장바구니의 모든 기능을 사용할 수 있다

**장바구니 수량 조절**

- [❌] 각 장바구니 상품의 수량을 증가할 수 있다
- [❌] 각 장바구니 상품의 수량을 감소할 수 있다
- [❌] 수량 변경 시 총 금액이 실시간으로 업데이트된다

**장바구니 삭제**

- [❌] 각 상품에 삭제 버튼이 배치되어 있다
- [❌] 삭제 버튼 클릭 시 해당 상품이 장바구니에서 제거된다

**장바구니 선택 삭제**

- [❌] 각 상품에 선택을 위한 체크박스가 제공된다
- [❌] 선택 삭제 버튼이 있다
- [❌] 체크된 상품들만 일괄 삭제된다

**장바구니 전체 선택**

- [❌] 모든 상품을 한 번에 선택할 수 있는 마스터 체크박스가 있다
- [❌] 전체 선택 시 모든 상품의 체크박스가 선택된다
- [❌] 전체 해제 시 모든 상품의 체크박스가 해제된다

**장바구니 비우기**

- [❌] 장바구니에 있는 모든 상품을 한 번에 삭제할 수 있다

#### 상품 상세

**상품 클릭시 상세 페이지 이동**

- [✅] 상품 목록에서 상품 이미지나 상품 정보 클릭 시 상세 페이지로 이동한다
- [✅] URL이 `/product/{productId}` 형태로 변경된다
- [✅] 상품의 자세한 정보가 전용 페이지에서 표시된다

**상품 상세 페이지 기능**

- [✅] 상품 이미지, 설명, 가격 등의 상세 정보가 표시된다
- [✅] 전체 화면을 활용한 상세 정보 레이아웃이 제공된다

**상품 상세 - 장바구니 담기**

- [❌] 상품 상세 페이지에서 해당 상품을 장바구니에 추가할 수 있다
- [❌] 페이지 내에서 수량을 선택하여 장바구니에 추가할 수 있다
- [✅] 수량 증가/감소 버튼이 제공된다

**관련 상품 기능**

- [✅] 상품 상세 페이지에서 관련 상품들이 표시된다
- [✅] 같은 카테고리(category2)의 다른 상품들이 관련 상품으로 표시된다
- [✅] 관련 상품 클릭 시 해당 상품의 상세 페이지로 이동한다
- [✅] 현재 보고 있는 상품은 관련 상품에서 제외된다

**상품 상세 페이지 내 네비게이션**

- [✅] 상품 상세에서 상품 목록으로 돌아가는 버튼이 제공된다
- [✅] 브레드크럼을 통해 카테고리별 상품 목록으로 이동할 수 있다
- [❔] SPA 방식으로 페이지 간 이동이 부드럽게 처리된다

#### 사용자 피드백 시스템

**토스트 메시지**

- [❌] 장바구니 추가 시 성공 메시지가 토스트로 표시된다
- [❌] 장바구니 삭제, 선택 삭제, 전체 삭제 시 알림 메시지가 표시된다
- [❌] 토스트는 3초 후 자동으로 사라진다
- [❌] 토스트에 닫기 버튼이 제공된다
- [❌] 토스트 타입별로 다른 스타일이 적용된다 (success, info, error)

### 심화과제

#### SPA 네비게이션 및 URL 관리

**페이지 이동**

- [❔] 어플리케이션 내의 모든 페이지 이동(뒤로가기/앞으로가기를 포함)은 하여 새로고침이 발생하지 않아야 한다.

**상품 목록 - URL 쿼리 반영**

- [✅] 검색어가 URL 쿼리 파라미터에 저장된다
- [✅] 카테고리 선택이 URL 쿼리 파라미터에 저장된다
- [✅] 상품 옵션이 URL 쿼리 파라미터에 저장된다
- [✅] 정렬 조건이 URL 쿼리 파라미터에 저장된다
- [✅] 조건 변경 시 URL이 자동으로 업데이트된다
- [✅] URL을 통해 현재 검색/필터 상태를 공유할 수 있다

**상품 목록 - 새로고침 시 상태 유지**

- [✅] 새로고침 후 URL 쿼리에서 검색어가 복원된다
- [✅] 새로고침 후 URL 쿼리에서 카테고리가 복원된다
- [✅] 새로고침 후 URL 쿼리에서 옵션 설정이 복원된다
- [✅] 새로고침 후 URL 쿼리에서 정렬 조건이 복원된다
- [✅] 복원된 조건에 맞는 상품 데이터가 다시 로드된다

**장바구니 - 새로고침 시 데이터 유지**

- [❌] 장바구니 내용이 브라우저에 저장된다
- [❌] 새로고침 후에도 이전 장바구니 내용이 유지된다
- [❌] 장바구니의 선택 상태도 함께 유지된다

**상품 상세 - URL에 ID 반영**

- [✅] 상품 상세 페이지 이동 시 상품 ID가 URL 경로에 포함된다 (`/product/{productId}`)
- [✅] URL로 직접 접근 시 해당 상품의 상세 페이지가 자동으로 로드된다

**상품 상세 - 새로고침시 유지**

- [✅] 새로고침 후에도 URL의 상품 ID를 읽어서 해당 상품 상세 페이지가 유지된다

**404 페이지**

- [✅] 존재하지 않는 경로 접근 시 404 에러 페이지가 표시된다
- [✅] 홈으로 돌아가기 버튼이 제공된다

#### AI로 한 번 더 구현하기

- [❌] 기존에 구현한 기능을 AI로 다시 구현한다.
- [❌] 이 과정에서 직접 가공하는 것은 최대한 지양한다.

## 과제 셀프회고
처음에는 UI 템플릿이 주어졌으니 최대한 구글검색으로 개발하려고 했습니다. 하지만 속도가 너무 더디고 기한 내에 개발할 수 있는 양이 너무 적을 것 같아, AI 도움을 통해 학습하면서 개발해야 겠다고 판단했습니다. AI의 도움을 받아 작업을 진행했지만, 원리를 이해하고 제가 이해할 수 있는 코드로 수정하기 까지 시간이 많이 소요되었습니다. 그러다 보니 생각보다 작업한 양이 많지 않아 저에게 실망(?)하게 되었습니다.<br/>
Vanilla JS로 처음 개발해보았는데, 이번 과제를 통해 자주 사용해 오던 기술들의 근본적인 원리에 대해 다시 한번 생각해 볼 수 있는 계기가 되었습니다. 

### 기술적 성장
* **(상태관리)Observer**: 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴
* **동적경로에 대한 고찰**: 지금까지 next.js를 사용하면서, 당연하게 params.id 자동 제공되어 [product/:id] 라우팅된 것을 사용했었습니다. 그런데 이번에 Vanilla JS를 하면서 브라우저는 URL을 구분해 줄 뿐, [/product/123은 어떤 페이지인지, 123이 파라미터인지]를 모르기 때문에 [정적 경로와 동적 파라미터가 있는 경로를 매칭]해주는 함수(main.js-matchRoute())가 필요하다는 것을 다시 깨닫게 되었습니다. 

<!-- 예시
- 새로 학습한 개념
- 기존 지식의 재발견/심화
- 구현 과정에서의 기술적 도전과 해결
-->

### 자랑하고 싶은 코드
어떤 것이 잘된 코드인지 감이 안와요...<br/>
코드 자랑은 아니지만...(테스트 리스트에는 없었지만)검색에 해당하는 데이터가 없을 때의 VIEW를 추가했습니다.

<!-- 예시
- 특히 만족스러운 구현
- 리팩토링이 필요한 부분
- 코드 설계 관련 고민과 결정
-->

### 개선이 필요하다고 생각하는 코드
**검색에 따른 데이터 필터**
* 문제: page가 큰 곳에 있는 상품을 검색할 때, 버퍼링 발생. page 2이상인 상품을 검색할 때, 1페이지에 있는 것으로 검색한 후에 검색해야 나옴.
어떻게 해야하지? 아무런 조건이 없는 상태의 모든 데이터에서 먼저 검색값으로 필터를 건 후, 필터옵션을 걸어야 하나?

<!-- 예시
- 특히 만족스러운 구현
- 리팩토링이 필요한 부분
- 코드 설계 관련 고민과 결정
-->

### 학습 효과 분석
JS를 사용한 경험이 많이 없어서, 이것에 대해 다시 리마인드할 수 있어서 좋았습니다. 자주 사용하고 있는 기술들의 원리를 깨닫고, 더 나아가 스스로 개발할 수 있도록 고민하는 부분이 필요한 것 같습니다. 이러한 고민들이 결국 어떤 기술을 사용하든 웹 내의 동작 매커니즘 안에서 동일하게 사용되고 응용되는 것이라고 생각하기 때문입니다.

<!-- 예시
- 가장 큰 배움이 있었던 부분
- 추가 학습이 필요한 영역
- 실무 적용 가능성
-->

### 과제 피드백
과제의 각 요구사항들을 영상으로 제공해 주어서 좋았습니다.

<!-- 예시
- 과제에서 모호하거나 애매했던 부분
- 과제에서 좋았던 부분
-->

### AI 활용 경험 공유하기
한 페이지 내에서 간단한 기능을 구현할 때는 ChatPT를 사용했습니다.<br/>
Cursor는 간단한 기능을 구현해달라고 해도 생각보다 복잡하게 개발하는 경향이 있는 것 같습니다.<br/>
여러 파일들의 연관이 강할 때는 아무래도 Cursor를 사용해서 개발을 한 후, 수정된 내용에 관해 이야기를 하여 좀 더 간략화 및 가독성 좋게 수정해 나갑니다.(수정된 내용을 보고 제가 수동으로 다시 수정하여 이에 맞게 다시 수정해 달라고 하는 경우도 있습니다.) 

<!-- 예시
- 사용한 AI 도구 (예: ChatGPT, Copilot, Claude, Cursor, ...)
- 프롬프트를 작성한 과정
- AI가 일을 더 잘 하게 만든 방법
- 내가 작성한 코드와 비교하기
-->

## 리뷰 받고 싶은 내용
**상태관리** (결국 ai 돌려서 작업했습니다.)<br/>
[상태에 변화가 있을 때, 구독자에게 알림] 이와 같이 동작을 한다고 하는데 이것이 결국 observer 방식 아닌가요?
```
 // Signal 생성: [getter, setter, subscribe]
 const [getLoading, setLoading, subscribeLoading] = createSignal(true);
```
**검색**<br/>
* 문제: page가 큰 곳에 있는 상품을 검색할 때, 버퍼링이 발생합니다. page 2이상인 상품을 검색할 때, 1페이지에 있는 것으로 먼저 검색한 후에 검색해야 나옵니다.<br/>
* 고민: 아무런 조건이 없는 상태의 모든 데이터에서 먼저 검색값으로 필터를 건 후, 필터옵션을 걸어야 하나요?<br/>

**상품 전체 개수**<br/>
* 문제: 전체 데이터의 개수가 아닌, 현재 가져온 데이터의 개수를 보여주고 있습니다.<br/>
* 고민: getProduts()에는 이미 limit=20 있는데 이것을 없애면 되나요?<br/>

**상품 상세 페이지 내 네비게이션**<br/>
* (테스트 조건)SPA 방식으로 페이지 간 이동이 부드럽게 처리된다<br/>
→ 원하는 조건에 맞게 잘 실행이 되고 있는 것인지 어떻게 확인할 수 있나요?<br/>

**페이지 이동**<br/>
* (테스트 조건)어플리케이션 내의 모든 페이지 이동(뒤로가기/앞으로가기를 포함)은 하여 새로고침이 발생하지 않아야 한다.<br/>
→ 원하는 조건에 맞게 잘 실행이 되고 있는 것인지 어떻게 확인할 수 있나요?<br/>

<!--
피드백 받고 싶은 내용을 구체적으로 남겨주세요
모호한 요청은 피드백을 남기기 어렵습니다.

참고링크: https://chatgpt.com/share/675b6129-515c-8001-ba72-39d0fa4c7b62

모호한 질문의 예시)
- 무엇을 질문해야 할지 몰라서 코치님이 보시기에 고쳐야할것들 전반적으로 피드백 부탁드립니다.
- 코드 스타일에 대한 피드백 부탁드립니다.
- 코드 구조에 대한 피드백 부탁드립니다.
- 개념적인 오류에 대한 피드백 부탁드립니다.
- 추가 구현이 필요한 부분에 대한 피드백 부탁드립니다.

구체적인 질문의 예시)
- 파일A의 함수B와 그 안의 변수명을 보면 직관성이 떨어지는 것 같습니다. 함수와 변수 이름을 더 명확하게 지을 방법에 대해 조언해 주실 수 있나요?
- 현재 파일 단위로 코드를 분리했지만, 이번 주차 발제를 기준으로 봤을 때 모듈화나 계층화에서 부족함이 있는 것 같습니다. 특히 A와 B 부분에서 모듈화를 더 진행할지 그대로 둘지 고민하였습니다. (...구체적인 고민 사항 적기...). 코치님의 의견이 궁금합니다.
- 옵저버 패턴을 사용해 상태 관리 로직을 구현해 보려 했습니다. 제가 구현한 코드가 옵저버 패턴에 맞게 잘 구성되었는지 검토해 주시고, 보완할 부분을 제안해 주실 수 있을까요?
- 컴포넌트 A를 테스트 할 때 B와의 의존성 때문에 테스트 코드를 작성하려다 포기했습니다. A와 B의 의존성을 낮추고 테스트 가능성을 높이는 구조 개선 방안이 있을까요?
-->
