## 과제 체크포인트

### 배포 링크

<!--
배포 링크를 적어주세요
예시: https://<username>.github.io/front-7th-chapter2-1/

배포가 완료되지 않으면 과제를 통과할 수 없습니다.
배포 후에 정상 작동하는지 확인해주세요.
-->

### 기본과제

#### 상품목록

**상품 목록 로딩**

- [x] 페이지 접속 시 로딩 상태가 표시된다
- [x] 데이터 로드 완료 후 상품 목록이 렌더링된다
- [x] 로딩 실패 시 에러 상태가 표시된다
- [x] 에러 발생 시 재시도 버튼이 제공된다

**상품 목록 조회**

- [x] 각 상품의 기본 정보(이미지, 상품명, 가격)가 카드 형태로 표시된다

**한 페이지에 보여질 상품 수 선택**

- [x] 드롭다운에서 10, 20, 50, 100개 중 선택할 수 있으며 기본 값은 20개 이다.
- [x] 선택 변경 시 즉시 목록에 반영된다

**상품 정렬 기능**

- [x] 상품을 가격순/이름순으로 오름차순/내림차순 정렬을 할 수 있다.
- [x] 드롭다운을 통해 정렬 기준을 선택할 수 있다
- [x] 정렬 변경 시 즉시 목록에 반영된다

**무한 스크롤 페이지네이션**

- [x] 페이지 하단 근처 도달 시 다음 페이지 데이터가 자동 로드된다
- [x] 스크롤에 따라 계속해서 새로운 상품들이 목록에 추가된다
- [x] 새 데이터 로드 중일 때 로딩 인디케이터와 스켈레톤 UI가 표시된다
- [x] 홈 페이지에서만 무한 스크롤이 활성화된다

**상품을 장바구니에 담기**

- [x] 각 상품에 장바구니 추가 버튼이 있다
- [x] 버튼 클릭 시 해당 상품이 장바구니에 추가된다
- [x] 추가 완료 시 사용자에게 알림이 표시된다

**상품 검색**

- [x] 상품명 기반 검색을 위한 텍스트 입력 필드가 있다
- [x] 검색 버튼 클릭으로 검색이 수행된다
- [x] Enter 키로 검색이 수행된다
- [x] 검색어와 일치하는 상품들만 목록에 표시된다

**카테고리 선택**

- [x] 사용 가능한 카테고리들을 선택할 수 있는 UI가 제공된다
- [x] 선택된 카테고리에 해당하는 상품들만 표시된다
- [x] 전체 상품 보기로 돌아갈 수 있다
- [x] 2단계 카테고리 구조를 지원한다 (1depth, 2depth)

**카테고리 네비게이션**

- [x] 현재 선택된 카테고리 경로가 브레드크럼으로 표시된다
- [x] 브레드크럼의 각 단계를 클릭하여 상위 카테고리로 이동할 수 있다
- [x] "전체" > "1depth 카테고리" > "2depth 카테고리" 형태로 표시된다

**현재 상품 수 표시**

- [x] 현재 조건에서 조회된 총 상품 수가 화면에 표시된다
- [x] 검색이나 필터 적용 시 상품 수가 실시간으로 업데이트된다

#### 장바구니

**장바구니 모달**

- [x] 장바구니 아이콘 클릭 시 모달 형태로 장바구니가 열린다
- [x] X 버튼이나 배경 클릭으로 모달을 닫을 수 있다
- [x] ESC 키로 모달을 닫을 수 있다
- [x] 모달에서 장바구니의 모든 기능을 사용할 수 있다

**장바구니 수량 조절**

- [x] 각 장바구니 상품의 수량을 증가할 수 있다
- [x] 각 장바구니 상품의 수량을 감소할 수 있다
- [x] 수량 변경 시 총 금액이 실시간으로 업데이트된다

**장바구니 삭제**

- [x] 각 상품에 삭제 버튼이 배치되어 있다
- [x] 삭제 버튼 클릭 시 해당 상품이 장바구니에서 제거된다

**장바구니 선택 삭제**

- [x] 각 상품에 선택을 위한 체크박스가 제공된다
- [x] 선택 삭제 버튼이 있다
- [x] 체크된 상품들만 일괄 삭제된다

**장바구니 전체 선택**

- [x] 모든 상품을 한 번에 선택할 수 있는 마스터 체크박스가 있다
- [x] 전체 선택 시 모든 상품의 체크박스가 선택된다
- [x] 전체 해제 시 모든 상품의 체크박스가 해제된다

**장바구니 비우기**

- [x] 장바구니에 있는 모든 상품을 한 번에 삭제할 수 있다

#### 상품 상세

**상품 클릭시 상세 페이지 이동**

- [x] 상품 목록에서 상품 이미지나 상품 정보 클릭 시 상세 페이지로 이동한다
- [x] URL이 `/product/{productId}` 형태로 변경된다
- [x] 상품의 자세한 정보가 전용 페이지에서 표시된다

**상품 상세 페이지 기능**

- [x] 상품 이미지, 설명, 가격 등의 상세 정보가 표시된다
- [x] 전체 화면을 활용한 상세 정보 레이아웃이 제공된다

**상품 상세 - 장바구니 담기**

- [x] 상품 상세 페이지에서 해당 상품을 장바구니에 추가할 수 있다
- [x] 페이지 내에서 수량을 선택하여 장바구니에 추가할 수 있다
- [x] 수량 증가/감소 버튼이 제공된다

**관련 상품 기능**

- [x] 상품 상세 페이지에서 관련 상품들이 표시된다
- [x] 같은 카테고리(category2)의 다른 상품들이 관련 상품으로 표시된다
- [x] 관련 상품 클릭 시 해당 상품의 상세 페이지로 이동한다
- [x] 현재 보고 있는 상품은 관련 상품에서 제외된다

**상품 상세 페이지 내 네비게이션**

- [x] 상품 상세에서 상품 목록으로 돌아가는 버튼이 제공된다
- [x] 브레드크럼을 통해 카테고리별 상품 목록으로 이동할 수 있다
- [x] SPA 방식으로 페이지 간 이동이 부드럽게 처리된다

#### 사용자 피드백 시스템

**토스트 메시지**

- [x] 장바구니 추가 시 성공 메시지가 토스트로 표시된다
- [x] 장바구니 삭제, 선택 삭제, 전체 삭제 시 알림 메시지가 표시된다
- [x] 토스트는 3초 후 자동으로 사라진다
- [x] 토스트에 닫기 버튼이 제공된다
- [x] 토스트 타입별로 다른 스타일이 적용된다 (success, info, error)

### 심화과제

#### SPA 네비게이션 및 URL 관리

**페이지 이동**

- [x] 어플리케이션 내의 모든 페이지 이동(뒤로가기/앞으로가기를 포함)은 하여 새로고침이 발생하지 않아야 한다.

**상품 목록 - URL 쿼리 반영**

- [x] 검색어가 URL 쿼리 파라미터에 저장된다
- [x] 카테고리 선택이 URL 쿼리 파라미터에 저장된다
- [x] 상품 옵션이 URL 쿼리 파라미터에 저장된다
- [x] 정렬 조건이 URL 쿼리 파라미터에 저장된다
- [x] 조건 변경 시 URL이 자동으로 업데이트된다
- [x] URL을 통해 현재 검색/필터 상태를 공유할 수 있다

**상품 목록 - 새로고침 시 상태 유지**

- [x] 새로고침 후 URL 쿼리에서 검색어가 복원된다
- [x] 새로고침 후 URL 쿼리에서 카테고리가 복원된다
- [x] 새로고침 후 URL 쿼리에서 옵션 설정이 복원된다
- [x] 새로고침 후 URL 쿼리에서 정렬 조건이 복원된다
- [x] 복원된 조건에 맞는 상품 데이터가 다시 로드된다

**장바구니 - 새로고침 시 데이터 유지**

- [x] 장바구니 내용이 브라우저에 저장된다
- [x] 새로고침 후에도 이전 장바구니 내용이 유지된다
- [x] 장바구니의 선택 상태도 함께 유지된다

**상품 상세 - URL에 ID 반영**

- [x] 상품 상세 페이지 이동 시 상품 ID가 URL 경로에 포함된다 (`/product/{productId}`)
- [x] URL로 직접 접근 시 해당 상품의 상세 페이지가 자동으로 로드된다

**상품 상세 - 새로고침시 유지**

- [x] 새로고침 후에도 URL의 상품 ID를 읽어서 해당 상품 상세 페이지가 유지된다

**404 페이지**

- [ ] 존재하지 않는 경로 접근 시 404 에러 페이지가 표시된다
- [ ] 홈으로 돌아가기 버튼이 제공된다

#### AI로 한 번 더 구현하기

- [ ] 기존에 구현한 기능을 AI로 다시 구현한다.
- [ ] 이 과정에서 직접 가공하는 것은 최대한 지양한다.

## 과제 셀프회고

<!-- 과제에 대한 회고를 작성해주세요 -->

과제 의도와는 다르게, AI를 너무나 적극 활용한 것 같아 아쉽습니다.

### 기술적 성장

- **커스텀 SPA 라우터 구현**: React Router나 Vue Router 같은 라이브러리 없이 순수 JavaScript로 SPA 라우터를 직접 구현했습니다. History API와 URL 파싱, 경로 매칭 로직을 구현하면서 라우팅의 동작 원리를 깊이 이해할 수 있었습니다.

- **옵저버 패턴을 활용한 상태 관리**: 전역 상태 관리를 위한 간단한 스토어를 구현했습니다. 옵저버 패턴을 사용하여 상태 변경 시 구독자들에게 자동으로 알림을 보내는 메커니즘을 구현했습니다. 이 과정에서 React의 상태 관리 개념과 유사한 패턴을 구현하려고 했는데, 잘 된건지는 모르겠습니다.

- **IntersectionObserver API**: 무한 스크롤을 구현하면서 IntersectionObserver API를 처음 사용해봤습니다. 기존의 scroll 이벤트 리스너 대신 더 효율적인 방법으로 뷰포트 교차를 감지할 수 있다는 것을 배웠습니다.

- **URL 쿼리 파라미터와 상태 동기화**: 검색어, 카테고리, 정렬 조건 등을 URL 쿼리 파라미터로 관리하면서, 새로고침 후에도 상태를 복원할 수 있도록 구현했습니다. 이 과정에서 URLSearchParams API를 활용하는 방법을 학습했습니다.

- **이벤트 기반 아키텍처**: EventBus를 구현하여 컴포넌트 간 느슨한 결합을 유지했습니다. 이벤트 기반 통신을 통해 라우터, 상태 관리, UI 컴포넌트 간의 의존성을 줄일 수 있었습니다.

- **Enhancer 패턴**: 라우터의 기능을 확장하기 위해 enhancer 패턴을 사용했습니다. 라우터에 새로운 기능을 추가할 때 기존 코드를 수정하지 않고도 확장할 수 있는 구조를 만들어보았습니다.

### 자랑하고 싶은 코드

- **appStore.js의 상태 관리 구조**: 단순하면서도 확장 가능한 상태 관리 구조를 만들었습니다. `updateHomepage`, `updateCart` 함수를 통해 상태 업데이트를 일관되게 처리하고, 옵저버 패턴을 통해 자동으로 UI를 업데이트하도록 구현했습니다.

- **URL 상태 동기화**: 검색, 필터, 정렬 등의 상태를 URL 쿼리 파라미터로 관리하여 브라우저의 뒤로가기/앞으로가기와 새로고침 시에도 상태가 유지되도록 구현했습니다.

### 개선이 필요하다고 생각하는 코드

- **이벤트 리스너 정리**: `homepageEvents.js`나 `CartModal.js`에서 이벤트 리스너를 등록할 때, cleanup 함수를 제대로 호출하지 않는 부분이 있습니다. 메모리 누수를 방지하기 위해 이벤트 리스너 정리 로직을 더 체계적으로 관리해야 합니다.

- **에러 처리**: API 호출 실패 시 에러 처리가 일관되지 않습니다. 에러 타입에 따라 다른 처리를 하거나, 전역 에러 핸들러를 추가하는 것이 좋을 것 같습니다.

- **타입 안정성**: TypeScript를 사용하지 않아 타입 에러를 런타임에 발견하게 됩니다. 객체의 속성에 접근할 때 옵셔널 체이닝을 많이 사용하지만, 더 명확한 타입 정의가 필요합니다.

- **컴포넌트 구조**: 일부 컴포넌트에서 HTML 문자열을 직접 생성하는 부분이 많은데, 이를 더 모듈화하고 재사용 가능한 구조로 개선할 수 있을 것 같습니다.

### 학습 효과 분석

- **가장 큰 배움이 있었던 부분**: SPA 라우터를 직접 구현하면서 라우팅의 동작 원리를 깊이 이해할 수 있었습니다. 또한 URL과 상태를 동기화하는 방법을 학습하면서, 사용자 경험을 개선하는 방법을 배울 수 있었습니다.

- **추가 학습이 필요한 영역**:

  - 테스트 코드 작성 방법 (단위 테스트, 통합 테스트)
  - 성능 최적화 (가상 스크롤, 코드 스플리팅)
  - 접근성 (ARIA 속성, 키보드 네비게이션)
  - 상태 관리 라이브러리 (Redux, Zustand 등)의 내부 동작 원리
  - 배포 ...

- **실무 적용 가능성**: 이번 과제에서 구현한 패턴들은 실무에서도 적용 가능합니다. 특히 커스텀 라우터 구현 경험은 프레임워크 없이 순수 JavaScript로 웹 애플리케이션을 구축할 때 유용할 것입니다. 또한 옵저버 패턴을 활용한 상태 관리는 작은 규모의 프로젝트에서 상태 관리 라이브러리 없이도 충분히 사용할 수 있습니다.

### 과제 피드백

- **과제에서 모호하거나 애매했던 부분**:

  - "새로고침 시 상태 유지" 요구사항에서, 장바구니의 선택 상태(체크박스)도 함께 유지해야 하는지 명확하지 않았습니다. 현재는 장바구니 아이템만 유지하고 선택 상태는 유지하지 않도록 구현했습니다.
  - 404 페이지 구현이 심화 과제에 포함되어 있지만, 라우터에서 이미 notFound 핸들러를 제공하고 있어 구현이 간단했습니다. 다만 체크박스가 비어있어 아직 구현하지 않은 상태입니다.

- **과제에서 좋았던 부분**:
  - URL 상태 동기화와 같은 실무에서 자주 사용하는 패턴을 학습할 수 있어 유용했습니다.
  - E2E 테스트를 통해 구현한 기능이 제대로 동작하는지 확인할 수 있어 좋았습니다.

### AI 활용 경험 공유하기

- **사용한 AI 도구**: Cursor

- **프롬프트를 작성한 과정**:

  - 구체적인 요구사항을 명확히 기술했습니다 (예: "IntersectionObserver를 사용하여 무한 스크롤을 구현해줘")
  - 기존 코드 구조를 함께 제공하여 일관성 있는 코드를 생성받을 수 있도록 했습니다
  - 에러가 발생했을 때는 에러 메시지와 관련 코드를 함께 제공하여 정확한 해결책을 얻을 수 있도록 했습니다

- **AI가 일을 더 잘 하게 만든 방법**:

  - 복잡한 로직을 구현할 때 AI에게 먼저 구현을 요청한 후, 생성된 코드를 검토하고 필요한 부분을 수정했습니다
  - 반복적인 코드 작성(예: 이벤트 리스너 바인딩)을 AI에게 요청하여 생산성을 높였습니다
  - 에러 디버깅 시 AI에게 에러 메시지와 컨텍스트를 제공하여 빠르게 문제를 해결할 수 있었습니다

- **내가 작성한 코드와 비교하기**:
  - AI가 생성한 코드는 대체로 더 간결하고 명확한 변수명을 사용하는 경향이 있습니다
  - 다만, 프로젝트의 전체 구조를 고려하지 않고 생성하는 경우가 있어, 생성된 코드를 프로젝트 구조에 맞게 수정해야 했습니다
  - 에러 처리나 엣지 케이스 처리는 AI가 놓치는 경우가 많아, 이를 직접 추가해야 했습니다

## 리뷰 받고 싶은 내용

<!--
피드백 받고 싶은 내용을 구체적으로 남겨주세요
모호한 요청은 피드백을 남기기 어렵습니다.

참고링크: https://chatgpt.com/share/675b6129-515c-8001-ba72-39d0fa4c7b62

모호한 질문의 예시)
- 무엇을 질문해야 할지 몰라서 코치님이 보시기에 고쳐야할것들 전반적으로 피드백 부탁드립니다.
- 코드 스타일에 대한 피드백 부탁드립니다.
- 코드 구조에 대한 피드백 부탁드립니다.
- 개념적인 오류에 대한 피드백 부탁드립니다.
- 추가 구현이 필요한 부분에 대한 피드백 부탁드립니다.

구체적인 질문의 예시)
- 파일A의 함수B와 그 안의 변수명을 보면 직관성이 떨어지는 것 같습니다. 함수와 변수 이름을 더 명확하게 지을 방법에 대해 조언해 주실 수 있나요?
- 현재 파일 단위로 코드를 분리했지만, 이번 주차 발제를 기준으로 봤을 때 모듈화나 계층화에서 부족함이 있는 것 같습니다. 특히 A와 B 부분에서 모듈화를 더 진행할지 그대로 둘지 고민하였습니다. (...구체적인 고민 사항 적기...). 코치님의 의견이 궁금합니다.
- 옵저버 패턴을 사용해 상태 관리 로직을 구현해 보려 했습니다. 제가 구현한 코드가 옵저버 패턴에 맞게 잘 구성되었는지 검토해 주시고, 보완할 부분을 제안해 주실 수 있을까요?
- 컴포넌트 A를 테스트 할 때 B와의 의존성 때문에 테스트 코드를 작성하려다 포기했습니다. A와 B의 의존성을 낮추고 테스트 가능성을 높이는 구조 개선 방안이 있을까요?
-->
